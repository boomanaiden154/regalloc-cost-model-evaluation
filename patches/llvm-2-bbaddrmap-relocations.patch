diff --git a/llvm/include/llvm/Object/ELF.h b/llvm/include/llvm/Object/ELF.h
index 1664ff96542f..efae0aa30c95 100644
--- a/llvm/include/llvm/Object/ELF.h
+++ b/llvm/include/llvm/Object/ELF.h
@@ -14,6 +14,7 @@
 #define LLVM_OBJECT_ELF_H
 
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/MapVector.h"
 #include "llvm/ADT/SmallString.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringRef.h"
@@ -391,7 +392,12 @@ public:
   Expected<ArrayRef<T>> getSectionContentsAsArray(const Elf_Shdr &Sec) const;
   Expected<ArrayRef<uint8_t>> getSectionContents(const Elf_Shdr &Sec) const;
   Expected<ArrayRef<uint8_t>> getSegmentContents(const Elf_Phdr &Phdr) const;
-  Expected<std::vector<BBAddrMap>> decodeBBAddrMap(const Elf_Shdr &Sec) const;
+  Expected<std::vector<BBAddrMap>>
+  decodeBBAddrMap(const Elf_Shdr &Sec,
+                  const std::optional<Elf_Shdr> &RelaSec = {}) const;
+  Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+  getSectionAndRelocations(
+      std::function<Expected<bool>(const Elf_Shdr &)> IsMatch) const;
 
   void createFakeSections();
 };
diff --git a/llvm/lib/Object/ELF.cpp b/llvm/lib/Object/ELF.cpp
index 81c9a097170d..3e06c99fa95e 100644
--- a/llvm/lib/Object/ELF.cpp
+++ b/llvm/lib/Object/ELF.cpp
@@ -639,8 +639,25 @@ ELFFile<ELFT>::toMappedAddr(uint64_t VAddr, WarningHandler WarnHandler) const {
 }
 
 template <class ELFT>
-Expected<std::vector<BBAddrMap>>
-ELFFile<ELFT>::decodeBBAddrMap(const Elf_Shdr &Sec) const {
+Expected<std::vector<BBAddrMap>> ELFFile<ELFT>::decodeBBAddrMap(
+    const Elf_Shdr &Sec, const std::optional<Elf_Shdr> &RelaSec) const {
+  bool IsRelocatable = getHeader().e_type == ELF::ET_REL;
+  assert(!IsRelocatable || (IsRelocatable && RelaSec));
+
+  // This DenseMap maps the offset of each function (the location of the 
+  // reference to the function in the bbaddrmap section) to the addend
+  // (the location of the function in the text section).
+  llvm::DenseMap<uint64_t, uint64_t> FunctionOffsetTranslations;
+  if (IsRelocatable && RelaSec) {
+    Expected<Elf_Rela_Range> Relas = this->relas(*RelaSec);
+    if (!Relas)
+      return createError("unable to read relocations for section " +
+                         describe(*this, Sec) + ": " +
+                         toString(Relas.takeError()));
+    for (Elf_Rela Rela : *Relas) {
+      FunctionOffsetTranslations[Rela.r_offset] = Rela.r_addend;
+    }
+  }
   Expected<ArrayRef<uint8_t>> ContentsOrErr = getSectionContents(Sec);
   if (!ContentsOrErr)
     return ContentsOrErr.takeError();
@@ -680,7 +697,17 @@ ELFFile<ELFT>::decodeBBAddrMap(const Elf_Shdr &Sec) const {
                            Twine(static_cast<int>(Version)));
       Data.getU8(Cur); // Feature byte
     }
+    uint64_t SectionOffset = Cur.tell();
     uintX_t Address = static_cast<uintX_t>(Data.getAddress(Cur));
+    if (IsRelocatable) {
+      assert(Address == 0);
+      auto FOTIterator = FunctionOffsetTranslations.find(SectionOffset);
+      if (FOTIterator == FunctionOffsetTranslations.end())
+        return createError("Failed to get relocation data for offset: " +
+                           Twine(SectionOffset) + " in section " +
+                           describe(*this, Sec));
+        Address = FOTIterator->second;
+    }
     uint32_t NumBlocks = ReadULEB128AsUInt32();
     std::vector<BBAddrMap::BBEntry> BBEntries;
     uint32_t PrevBBEndOffset = 0;
@@ -706,6 +733,50 @@ ELFFile<ELFT>::decodeBBAddrMap(const Elf_Shdr &Sec) const {
   return FunctionEntries;
 }
 
+template <class ELFT>
+Expected<
+    llvm::MapVector<const typename ELFT::Shdr *, const typename ELFT::Shdr *>>
+ELFFile<ELFT>::getSectionAndRelocations(
+    std::function<Expected<bool>(const Elf_Shdr &)> IsMatch) const {
+  llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> SecToRelocMap;
+  Error Errors = Error::success();
+  for (const Elf_Shdr &Sec : cantFail(this->sections())) {
+    Expected<bool> DoesSectionMatch = IsMatch(Sec);
+    if (!DoesSectionMatch) {
+      Errors = joinErrors(std::move(Errors), DoesSectionMatch.takeError());
+      continue;
+    }
+    if (*DoesSectionMatch)
+      if (SecToRelocMap.insert(std::make_pair(&Sec, (const Elf_Shdr *)nullptr))
+              .second)
+        continue;
+
+    if (Sec.sh_type != ELF::SHT_RELA && Sec.sh_type != ELF::SHT_REL)
+      continue;
+
+    Expected<const Elf_Shdr *> RelSecOrErr = this->getSection(Sec.sh_info);
+    if (!RelSecOrErr) {
+      Errors = joinErrors(std::move(Errors),
+                          createError(describe(*this, Sec) +
+                                      ": failed to get a relocated section: " +
+                                      toString(RelSecOrErr.takeError())));
+      continue;
+    }
+    const Elf_Shdr *ContentsSec = *RelSecOrErr;
+    Expected<bool> DoesRelTargetMatch = IsMatch(*ContentsSec);
+    if (!DoesRelTargetMatch) {
+      Errors = joinErrors(std::move(Errors), DoesRelTargetMatch.takeError());
+      continue;
+    }
+    if (*DoesRelTargetMatch)
+      SecToRelocMap[ContentsSec] = &Sec;
+  }
+  if (Errors) {
+    return Errors;
+  }
+  return SecToRelocMap;
+}
+
 template class llvm::object::ELFFile<ELF32LE>;
 template class llvm::object::ELFFile<ELF32BE>;
 template class llvm::object::ELFFile<ELF64LE>;
diff --git a/llvm/lib/Object/ELFObjectFile.cpp b/llvm/lib/Object/ELFObjectFile.cpp
index 4ce240324b19..3fcbb91f9dae 100644
--- a/llvm/lib/Object/ELFObjectFile.cpp
+++ b/llvm/lib/Object/ELFObjectFile.cpp
@@ -681,12 +681,14 @@ template <class ELFT>
 Expected<std::vector<BBAddrMap>> static readBBAddrMapImpl(
     const ELFFile<ELFT> &EF, std::optional<unsigned> TextSectionIndex) {
   using Elf_Shdr = typename ELFT::Shdr;
+  bool IsRelocatable = EF.getHeader().e_type == ELF::ET_REL;
   std::vector<BBAddrMap> BBAddrMaps;
+
   const auto &Sections = cantFail(EF.sections());
-  for (const Elf_Shdr &Sec : Sections) {
+  auto IsMatch = [&](const Elf_Shdr &Sec) -> Expected<bool> {
     if (Sec.sh_type != ELF::SHT_LLVM_BB_ADDR_MAP &&
         Sec.sh_type != ELF::SHT_LLVM_BB_ADDR_MAP_V0)
-      continue;
+      return false;
     if (TextSectionIndex) {
       Expected<const Elf_Shdr *> TextSecOrErr = EF.getSection(Sec.sh_link);
       if (!TextSecOrErr)
@@ -694,11 +696,24 @@ Expected<std::vector<BBAddrMap>> static readBBAddrMapImpl(
                            describe(EF, Sec) + ": " +
                            toString(TextSecOrErr.takeError()));
       if (*TextSectionIndex != std::distance(Sections.begin(), *TextSecOrErr))
-        continue;
+        return false;
     }
-    Expected<std::vector<BBAddrMap>> BBAddrMapOrErr = EF.decodeBBAddrMap(Sec);
+    return true;
+  };
+
+  Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+      SectionRelocMapOrErr = EF.getSectionAndRelocations(IsMatch);
+  if (!SectionRelocMapOrErr)
+    return SectionRelocMapOrErr.takeError();
+
+  for (auto const &[Sec, RelocSec] : *SectionRelocMapOrErr) {
+    std::optional<Elf_Shdr> RelaSec = {};
+    if (IsRelocatable)
+      RelaSec = *RelocSec;
+    Expected<std::vector<BBAddrMap>> BBAddrMapOrErr =
+        EF.decodeBBAddrMap(*Sec, RelaSec);
     if (!BBAddrMapOrErr)
-      return createError("unable to read " + describe(EF, Sec) + ": " +
+      return createError("unable to read " + describe(EF, *Sec) + ": " +
                          toString(BBAddrMapOrErr.takeError()));
     std::move(BBAddrMapOrErr->begin(), BBAddrMapOrErr->end(),
               std::back_inserter(BBAddrMaps));
diff --git a/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-disassemble-symbolize-operands.yaml b/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-disassemble-symbolize-operands.yaml
index 2d4a52211f81..cf4ac77b3d15 100644
--- a/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-disassemble-symbolize-operands.yaml
+++ b/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-disassemble-symbolize-operands.yaml
@@ -5,19 +5,12 @@
 # UNSUPPORTED: system-windows
 
 ## Executable object file.
-# RUN: yaml2obj --docnum=1 -DTYPE=ET_EXEC -DFOO_ADDR=0x4000 -DBAR_ADDR=0x5000 %s -o %t1
+# RUN: yaml2obj --docnum=1 -DFOO_ADDR=0x4000 -DBAR_ADDR=0x5000 %s -o %t1
 # RUN: llvm-objdump %t1 -d --symbolize-operands -M intel --no-show-raw-insn --no-leading-addr | \
 # RUN:   FileCheck %s -DSYM=symbol --match-full-lines --check-prefixes=INTEL
 # RUN: llvm-objdump %t1 -d --symbolize-operands -M att --no-show-raw-insn --no-leading-addr | \
 # RUN:   FileCheck %s -DSYM=symbol --match-full-lines --check-prefixes=ATT
 
-## Relocatable object file.
-# RUN: yaml2obj --docnum=1 -DTYPE=ET_REL -DFOO_ADDR=0x0 -DBAR_ADDR=0x0 %s -o %t2
-# RUN: llvm-objdump %t2 -d --symbolize-operands -M intel --no-show-raw-insn --no-leading-addr | \
-# RUN:   FileCheck %s -DSYM=foo+0x200c --match-full-lines --check-prefix=INTEL
-# RUN: llvm-objdump %t2 -d --symbolize-operands -M att --no-show-raw-insn --no-leading-addr | \
-# RUN:   FileCheck %s -DSYM=foo+0x200c --match-full-lines --check-prefix=ATT
-
 ## Executable object file with a single SHT_LLVM_BB_ADDR_MAP for multiple text sections.
 # RUN: yaml2obj --docnum=2 %s -o %t3
 # RUN: llvm-objdump %t3 -d --symbolize-operands -M intel --no-show-raw-insn --no-leading-addr | \
@@ -78,7 +71,7 @@
 FileHeader:
   Class:   ELFCLASS64
   Data:    ELFDATA2LSB
-  Type:    [[TYPE]]
+  Type:    ET_EXEC
   Machine: EM_X86_64
 Sections:
   - Name:    .text.foo
diff --git a/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-symbolize-relocatable.yaml b/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-symbolize-relocatable.yaml
new file mode 100644
index 000000000000..31fbcffbf474
--- /dev/null
+++ b/llvm/test/tools/llvm-objdump/X86/elf-bbaddrmap-symbolize-relocatable.yaml
@@ -0,0 +1,137 @@
+## Test that in the presence of SHT_LLVM_BB_ADDR_MAP sections,
+## --symbolize-operands can display <BB*> labels properly in a relocatable
+## object file.
+
+# Fails on windows (https://github.com/llvm/llvm-project/issues/60013).
+# UNSUPPORTED: system-windows
+
+## Relocatable Object file.
+# RUN: yaml2obj %s -o %t1
+# RUN: llvm-objdump %t1 -d --symbolize-operands -M intel --no-show-raw-insn --no-leading-addr | \
+# RUN:   FileCheck %s -DSYM=symbol --match-full-lines --check-prefixes=INTEL
+# RUN: llvm-objdump %t1 -d --symbolize-operands -M att --no-show-raw-insn --no-leading-addr | \
+# RUN:   FileCheck %s -DSYM=symbol --match-full-lines --check-prefixes=ATT
+
+--- !ELF
+FileHeader:
+  Class:           ELFCLASS64
+  Data:            ELFDATA2LSB
+  Type:            ET_REL
+  Machine:         EM_X86_64
+  SectionHeaderStringTable: .strtab
+Sections:
+  - Name:    .text
+    Type:    SHT_PROGBITS
+    Flags:   [ SHF_ALLOC, SHF_EXECINSTR ]
+    Content: 554889E5897DFC8B45FCC1E0015DC390554889E5897DF8837DF8050F8E0E0000008B45F883E8058945FCE9060000008B45F88945FC8B45FC5DC3
+  - Name:    .llvm_bb_addr_map
+    Type:    SHT_LLVM_BB_ADDR_MAP
+    Link:    .text
+    Entries:
+      - Version: 2
+        BBEntries:
+          - ID:              0
+            AddressOffset:   0x0
+            Size:            0xF
+            Metadata:        0x1
+      - Version: 2
+        BBEntries:
+          - ID:              0
+            AddressOffset:   0x0
+            Size:            0x11
+            Metadata:        0x8
+          - ID:              1
+            AddressOffset:   0x0
+            Size:            0xE
+            Metadata:        0x0
+          - ID:              2
+            AddressOffset:   0x0
+            Size:            0x6
+            Metadata:        0x8
+          - ID:              3
+            AddressOffset:   0x0
+            Size:            0x5
+            Metadata:        0x1
+  - Name:  .rela.llvm_bb_addr_map
+    Type:  SHT_RELA
+    Flags: [ SHF_INFO_LINK ]
+    Link:  .symtab
+    Info:  .llvm_bb_addr_map
+    Relocations:
+      - Offset: 0x2
+        Symbol: .text
+        Type:   R_X86_64_64
+      - Offset: 0x11
+        Symbol: .text
+        Type:   R_X86_64_64
+        Addend: 16
+Symbols:
+  - Name:    a
+    Section: .text
+    Value:   0x0
+  - Name:    c
+    Section: .text
+    Value:   0x10
+  - Name:    .text
+    Type:    STT_SECTION
+    Section: .text
+
+# ATT:      <a>:
+# ATT-NEXT: <BB0>:
+# ATT-NEXT:   pushq   %rbp
+# ATT-NEXT:   movq    %rsp, %rbp
+# ATT-NEXT:   movl    %edi, -0x4(%rbp)
+# ATT-NEXT:   movl    -0x4(%rbp), %eax
+# ATT-NEXT:   shll    $0x1, %eax
+# ATT-NEXT:   popq    %rbp
+# ATT-NEXT:   retq
+# ATT-NEXT:   nop
+# ATT:      <c>:
+# ATT-NEXT: <BB0>:
+# ATT-NEXT:   pushq   %rbp
+# ATT-NEXT:   movq    %rsp, %rbp
+# ATT-NEXT:   movl    %edi, -0x8(%rbp)
+# ATT-NEXT:   cmpl    $0x5, -0x8(%rbp)
+# ATT-NEXT:   jle      <BB2>
+# ATT-NEXT: <BB1>:
+# ATT-NEXT:   movl    -0x8(%rbp), %eax
+# ATT-NEXT:   subl    $0x5, %eax
+# ATT-NEXT:   movl    %eax, -0x4(%rbp)
+# ATT-NEXT:   jmp      <BB3>
+# ATT-NEXT: <BB2>:
+# ATT-NEXT:   movl    -0x8(%rbp), %eax
+# ATT-NEXT:   movl    %eax, -0x4(%rbp)
+# ATT-NEXT: <BB3>:
+# ATT-NEXT:   movl    -0x4(%rbp), %eax
+# ATT-NEXT:   popq    %rbp
+# ATT-NEXT:   retq
+
+# INTEL:      <a>:
+# INTEL-NEXT: <BB0>:
+# INTEL-NEXT:   push    rbp
+# INTEL-NEXT:   mov     rbp, rsp
+# INTEL-NEXT:   mov     dword ptr [rbp - 0x4], edi
+# INTEL-NEXT:   mov     eax, dword ptr [rbp - 0x4]
+# INTEL-NEXT:   shl     eax, 0x1
+# INTEL-NEXT:   pop     rbp
+# INTEL-NEXT:   ret
+# INTEL-NEXT:   nop
+# INTEL:      <c>:
+# INTEL-NEXT: <BB0>:
+# INTEL-NEXT:   push    rbp
+# INTEL-NEXT:   mov     rbp, rsp
+# INTEL-NEXT:   mov     dword ptr [rbp - 0x8], edi
+# INTEL-NEXT:   cmp     dword ptr [rbp - 0x8], 0x5
+# INTEL-NEXT:   jle      <BB2>
+# INTEL-NEXT: <BB1>:
+# INTEL-NEXT:   mov     eax, dword ptr [rbp - 0x8]
+# INTEL-NEXT:   sub     eax, 0x5
+# INTEL-NEXT:   mov     dword ptr [rbp - 0x4], eax
+# INTEL-NEXT:   jmp      <BB3>
+# INTEL-NEXT: <BB2>:
+# INTEL-NEXT:   mov     eax, dword ptr [rbp - 0x8]
+# INTEL-NEXT:   mov     dword ptr [rbp - 0x4], eax
+# INTEL-NEXT: <BB3>:
+# INTEL-NEXT:   mov     eax, dword ptr [rbp - 0x4]
+# INTEL-NEXT:   pop     rbp
+# INTEL-NEXT:   ret
diff --git a/llvm/test/tools/llvm-readobj/ELF/bb-addr-map-relocatable.test b/llvm/test/tools/llvm-readobj/ELF/bb-addr-map-relocatable.test
new file mode 100644
index 000000000000..e88d040fbde3
--- /dev/null
+++ b/llvm/test/tools/llvm-readobj/ELF/bb-addr-map-relocatable.test
@@ -0,0 +1,131 @@
+## This test checks how we handle the --bb-addr-map option on relocatable
+## object files.
+
+## Fails on windows (https://github.com/llvm/llvm-project/issues/60013).
+# UNSUPPORTED: system-windows
+
+# RUN: yaml2obj %s -o %t1.o
+# RUN: llvm-readobj %t1.o --bb-addr-map | FileCheck %s
+
+# CHECK:      BBAddrMap [
+# CHECK-NEXT:   Function {
+# CHECK-NEXT:     At: 0x0
+# CHECK-NEXT:     Name: <?>
+# CHECK-NEXT:     BB entries [
+# CHECK-NEXT:       {
+# CHECK-NEXT:         ID: 0
+# CHECK-NEXT:         Offset: 0x0
+# CHECK-NEXT:         Size: 0xF
+# CHECK-NEXT:         HasReturn: Yes
+# CHECK-NEXT:         HasTailCall: No
+# CHECK-NEXT:         IsEHPad: No
+# CHECK-NEXT:         CanFallThrough: No
+# CHECK-NEXT:       }
+# CHECK-NEXT:     ]
+# CHECK-NEXT:   }
+# CHECK-NEXT:   Function {
+# CHECK-NEXT:     At: 0x10
+# CHECK-NEXT:     Name: <?>
+# CHECK-NEXT:     BB entries [
+# CHECK-NEXT:       {
+# CHECK-NEXT:         ID: 0
+# CHECK-NEXT:         Offset: 0x0
+# CHECK-NEXT:         Size: 0x11
+# CHECK-NEXT:         HasReturn: No
+# CHECK-NEXT:         HasTailCall: No
+# CHECK-NEXT:         IsEHPad: No
+# CHECK-NEXT:         CanFallThrough: Yes
+# CHECK-NEXT:       }
+# CHECK-NEXT:       {
+# CHECK-NEXT:         ID: 1
+# CHECK-NEXT:         Offset: 0x11
+# CHECK-NEXT:         Size: 0xE
+# CHECK-NEXT:         HasReturn: No
+# CHECK-NEXT:         HasTailCall: No
+# CHECK-NEXT:         IsEHPad: No
+# CHECK-NEXT:         CanFallThrough: No
+# CHECK-NEXT:       }
+# CHECK-NEXT:       {
+# CHECK-NEXT:         ID: 2
+# CHECK-NEXT:         Offset: 0x1F
+# CHECK-NEXT:         Size: 0x6
+# CHECK-NEXT:         HasReturn: No
+# CHECK-NEXT:         HasTailCall: No
+# CHECK-NEXT:         IsEHPad: No
+# CHECK-NEXT:         CanFallThrough: Yes
+# CHECK-NEXT:       }
+# CHECK-NEXT:       {
+# CHECK-NEXT:         ID: 3
+# CHECK-NEXT:         Offset: 0x25
+# CHECK-NEXT:         Size: 0x5
+# CHECK-NEXT:         HasReturn: Yes
+# CHECK-NEXT:         HasTailCall: No
+# CHECK-NEXT:         IsEHPad: No
+# CHECK-NEXT:         CanFallThrough: No
+# CHECK-NEXT:       }
+# CHECK-NEXT:     ]
+# CHECK-NEXT:   }
+# CHECK-NEXT: ]
+
+--- !ELF
+FileHeader:
+  Class:           ELFCLASS64
+  Data:            ELFDATA2LSB
+  Type:            ET_REL
+  Machine:         EM_X86_64
+  SectionHeaderStringTable: .strtab
+Sections:
+  - Name:    .text
+    Type:    SHT_PROGBITS
+    Flags:   [ SHF_ALLOC, SHF_EXECINSTR ]
+  - Name:    .llvm_bb_addr_map
+    Type:    SHT_LLVM_BB_ADDR_MAP
+    Link:    .text
+    Entries:
+      - Version: 2
+        BBEntries:
+          - ID:              0
+            AddressOffset:   0x0
+            Size:            0xF
+            Metadata:        0x1
+      - Version: 2
+        BBEntries:
+          - ID:              0
+            AddressOffset:   0x0
+            Size:            0x11
+            Metadata:        0x8
+          - ID:              1
+            AddressOffset:   0x0
+            Size:            0xE
+            Metadata:        0x0
+          - ID:              2
+            AddressOffset:   0x0
+            Size:            0x6
+            Metadata:        0x8
+          - ID:              3
+            AddressOffset:   0x0
+            Size:            0x5
+            Metadata:        0x1
+  - Name:  .rela.llvm_bb_addr_map
+    Type:  SHT_RELA
+    Flags: [ SHF_INFO_LINK ]
+    Link:  .symtab
+    Info:  .llvm_bb_addr_map
+    Relocations:
+      - Offset: 0x2
+        Symbol: .text
+        Type:   R_X86_64_64
+      - Offset: 0x11
+        Symbol: .text
+        Type:   R_X86_64_64
+        Addend: 16
+Symbols:
+  - Name:    a
+    Section: .text
+    Value:   0x0
+  - Name:    c
+    Section: .text
+    Value:   0x10
+  - Name:    .text
+    Type:    STT_SECTION
+    Section: .text
diff --git a/llvm/tools/llvm-readobj/ELFDumper.cpp b/llvm/tools/llvm-readobj/ELFDumper.cpp
index 45fff0cc4a76..ba4e9868c383 100644
--- a/llvm/tools/llvm-readobj/ELFDumper.cpp
+++ b/llvm/tools/llvm-readobj/ELFDumper.cpp
@@ -323,12 +323,6 @@ protected:
   void printRelocatableStackSizes(std::function<void()> PrintHeader);
   void printNonRelocatableStackSizes(std::function<void()> PrintHeader);
 
-  /// Retrieves sections with corresponding relocation sections based on
-  /// IsMatch.
-  void getSectionAndRelocations(
-      std::function<bool(const Elf_Shdr &)> IsMatch,
-      llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> &SecToRelocMap);
-
   const object::ELFObjectFile<ELFT> &ObjF;
   const ELFFile<ELFT> &Obj;
   StringRef FileName;
@@ -6196,38 +6190,11 @@ void ELFDumper<ELFT>::printNonRelocatableStackSizes(
   }
 }
 
-template <class ELFT>
-void ELFDumper<ELFT>::getSectionAndRelocations(
-    std::function<bool(const Elf_Shdr &)> IsMatch,
-    llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> &SecToRelocMap) {
-  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {
-    if (IsMatch(Sec))
-      if (SecToRelocMap.insert(std::make_pair(&Sec, (const Elf_Shdr *)nullptr))
-              .second)
-        continue;
-
-    if (Sec.sh_type != ELF::SHT_RELA && Sec.sh_type != ELF::SHT_REL)
-      continue;
-
-    Expected<const Elf_Shdr *> RelSecOrErr = Obj.getSection(Sec.sh_info);
-    if (!RelSecOrErr) {
-      reportUniqueWarning(describe(Sec) +
-                          ": failed to get a relocated section: " +
-                          toString(RelSecOrErr.takeError()));
-      continue;
-    }
-    const Elf_Shdr *ContentsSec = *RelSecOrErr;
-    if (IsMatch(*ContentsSec))
-      SecToRelocMap[ContentsSec] = &Sec;
-  }
-}
-
 template <class ELFT>
 void ELFDumper<ELFT>::printRelocatableStackSizes(
     std::function<void()> PrintHeader) {
   // Build a map between stack size sections and their corresponding relocation
   // sections.
-  llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> StackSizeRelocMap;
   auto IsMatch = [&](const Elf_Shdr &Sec) -> bool {
     StringRef SectionName;
     if (Expected<StringRef> NameOrErr = Obj.getSectionName(Sec))
@@ -6237,9 +6204,17 @@ void ELFDumper<ELFT>::printRelocatableStackSizes(
 
     return SectionName == ".stack_sizes";
   };
-  getSectionAndRelocations(IsMatch, StackSizeRelocMap);
 
-  for (const auto &StackSizeMapEntry : StackSizeRelocMap) {
+  Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+      StackSizeRelocMapOrErr = Obj.getSectionAndRelocations(IsMatch);
+  if (!StackSizeRelocMapOrErr) {
+    handleAllErrors(StackSizeRelocMapOrErr.takeError(), [&](StringError &SE) {
+      reportUniqueWarning(SE.getMessage());
+    });
+    return;
+  }
+
+  for (const auto &StackSizeMapEntry : *StackSizeRelocMapOrErr) {
     PrintHeader();
     const Elf_Shdr *StackSizesELFSec = StackSizeMapEntry.first;
     const Elf_Shdr *RelocSec = StackSizeMapEntry.second;
@@ -7063,14 +7038,20 @@ static bool getSymbolIndices(const typename ELFT::Shdr *CGRelSection,
 }
 
 template <class ELFT> void LLVMELFDumper<ELFT>::printCGProfile() {
-  llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> SecToRelocMap;
-
   auto IsMatch = [](const Elf_Shdr &Sec) -> bool {
     return Sec.sh_type == ELF::SHT_LLVM_CALL_GRAPH_PROFILE;
   };
-  this->getSectionAndRelocations(IsMatch, SecToRelocMap);
 
-  for (const auto &CGMapEntry : SecToRelocMap) {
+  Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+      SecToRelocMapOrErr = this->Obj.getSectionAndRelocations(IsMatch);
+  if (!SecToRelocMapOrErr) {
+    handleAllErrors(SecToRelocMapOrErr.takeError(), [&](StringError &SE) {
+      this->reportUniqueWarning(SE.getMessage());
+    });
+    return;
+  }
+
+  for (const auto &CGMapEntry : *SecToRelocMapOrErr) {
     const Elf_Shdr *CGSection = CGMapEntry.first;
     const Elf_Shdr *CGRelSection = CGMapEntry.second;
 
@@ -7109,20 +7090,31 @@ template <class ELFT> void LLVMELFDumper<ELFT>::printCGProfile() {
 
 template <class ELFT> void LLVMELFDumper<ELFT>::printBBAddrMaps() {
   bool IsRelocatable = this->Obj.getHeader().e_type == ELF::ET_REL;
-  for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {
-    if (Sec.sh_type != SHT_LLVM_BB_ADDR_MAP &&
-        Sec.sh_type != SHT_LLVM_BB_ADDR_MAP_V0) {
-      continue;
-    }
+  using Elf_Shdr = typename ELFT::Shdr;
+  auto IsMatch = [&](const Elf_Shdr &Sec) -> bool {
+    return Sec.sh_type == ELF::SHT_LLVM_BB_ADDR_MAP ||
+           Sec.sh_type == ELF::SHT_LLVM_BB_ADDR_MAP_V0;
+  };
+  Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>> SecRelocMapOrErr = this->Obj.getSectionAndRelocations(IsMatch);
+  if(!SecRelocMapOrErr) {
+    handleAllErrors(SecRelocMapOrErr.takeError(), [&](StringError &SE) {
+      this->reportUniqueWarning(SE.getMessage());
+    });
+    return;
+  }
+  for (auto const& [Sec, RelocSec] : *SecRelocMapOrErr) {
     std::optional<const Elf_Shdr *> FunctionSec;
     if (IsRelocatable)
       FunctionSec =
-          unwrapOrError(this->FileName, this->Obj.getSection(Sec.sh_link));
+          unwrapOrError(this->FileName, this->Obj.getSection(Sec->sh_link));
     ListScope L(W, "BBAddrMap");
+    std::optional<Elf_Shdr> RelaSec = {};
+    if(IsRelocatable)
+      RelaSec = *RelocSec;
     Expected<std::vector<BBAddrMap>> BBAddrMapOrErr =
-        this->Obj.decodeBBAddrMap(Sec);
+        this->Obj.decodeBBAddrMap(*Sec, RelaSec);
     if (!BBAddrMapOrErr) {
-      this->reportUniqueWarning("unable to dump " + this->describe(Sec) + ": " +
+      this->reportUniqueWarning("unable to dump " + this->describe(*Sec) + ": " +
                                 toString(BBAddrMapOrErr.takeError()));
       continue;
     }
@@ -7135,7 +7127,7 @@ template <class ELFT> void LLVMELFDumper<ELFT>::printBBAddrMaps() {
       if (FuncSymIndex.empty())
         this->reportUniqueWarning(
             "could not identify function symbol for address (0x" +
-            Twine::utohexstr(AM.Addr) + ") in " + this->describe(Sec));
+            Twine::utohexstr(AM.Addr) + ") in " + this->describe(*Sec));
       else
         FuncName = this->getStaticSymbolName(FuncSymIndex.front());
       W.printString("Name", FuncName);
diff --git a/llvm/unittests/Object/ELFObjectFileTest.cpp b/llvm/unittests/Object/ELFObjectFileTest.cpp
index 99595eba0962..90a11f864ab5 100644
--- a/llvm/unittests/Object/ELFObjectFileTest.cpp
+++ b/llvm/unittests/Object/ELFObjectFileTest.cpp
@@ -808,3 +808,107 @@ Sections:
   RelocatableFileYamlString += ContentsString;
   DoCheck(RelocatableFileYamlString);
 }
+
+TEST(ELFObjectFileTest, GetSectionAndRelocations) {
+  StringRef HeaderString(R"(
+--- !ELF
+FileHeader:
+  Class: ELFCLASS64
+  Data:  ELFDATA2LSB
+  Type:  ET_EXEC
+)");
+
+  using Elf_Shdr = Elf_Shdr_Impl<ELF64LE>;
+
+  auto DoCheckSucceeds =
+      [&](StringRef ContentsString,
+          std::function<Expected<bool>(const Elf_Shdr &)> Matcher) {
+        SmallString<0> Storage;
+        SmallString<128> FullYamlString(HeaderString);
+        FullYamlString += ContentsString;
+        Expected<ELFObjectFile<ELF64LE>> ElfOrErr =
+            toBinary<ELF64LE>(Storage, FullYamlString);
+        ASSERT_THAT_EXPECTED(ElfOrErr, Succeeded());
+
+        Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+            SecToRelocMapOrErr =
+                ElfOrErr->getELFFile().getSectionAndRelocations(Matcher);
+        ASSERT_THAT_EXPECTED(SecToRelocMapOrErr, Succeeded());
+
+        // basic verification to make sure we have the correct section types
+        for (auto const &[Sec, RelaSec] : *SecToRelocMapOrErr) {
+          ASSERT_EQ(Sec->sh_type, ELF::SHT_PROGBITS);
+          ASSERT_EQ(RelaSec->sh_type, ELF::SHT_RELA);
+        }
+      };
+
+  auto DoCheckFails =
+      [&](StringRef ContentsString,
+          std::function<Expected<bool>(const Elf_Shdr &)> Matcher,
+          const char *ErrorMessage) {
+        SmallString<0> Storage;
+        SmallString<128> FullYamlString(HeaderString);
+        FullYamlString += ContentsString;
+        Expected<ELFObjectFile<ELF64LE>> ElfOrErr =
+            toBinary<ELF64LE>(Storage, FullYamlString);
+        ASSERT_THAT_EXPECTED(ElfOrErr, Succeeded());
+
+        Expected<llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *>>
+            SecToRelocMapOrErr =
+                ElfOrErr->getELFFile().getSectionAndRelocations(Matcher);
+        ASSERT_THAT_ERROR(SecToRelocMapOrErr.takeError(),
+                          FailedWithMessage(ErrorMessage));
+      };
+
+  auto DefaultMatcher = [](const Elf_Shdr &Sec) -> bool {
+    return Sec.sh_type == ELF::SHT_PROGBITS;
+  };
+
+  StringRef TwoTextSections = R"(
+Sections:
+  - Name: .text
+    Type: SHT_PROGBITS
+    Flags: [ SHF_ALLOC, SHF_EXECINSTR ]
+  - Name: .rela.text
+    Type: SHT_RELA
+    Flags: [ SHF_INFO_LINK ]
+    Info: .text
+  - Name: .text2
+    Type: SHT_PROGBITS
+    Flags: [ SHF_ALLOC, SHF_EXECINSTR ]
+  - Name: .rela.text2
+    Type: SHT_RELA
+    Flags: [ SHF_INFO_LINK ]
+    Info: .text2
+)";
+  DoCheckSucceeds(TwoTextSections, DefaultMatcher);
+
+  StringRef OneTextSection = R"(
+Sections:
+  - Name: .text
+    Type: SHT_PROGBITS
+    Flags: [ SHF_ALLOC, SHF_EXECINSTR ]
+)";
+
+  auto ErroringMatcher = [](const Elf_Shdr &Sec) -> Expected<bool> {
+    if(Sec.sh_type == ELF::SHT_PROGBITS) {
+      return createError("This was supposed to fail.");
+    }
+    return false;
+  };
+
+  DoCheckFails(OneTextSection, ErroringMatcher,
+               "This was supposed to fail.");
+
+  StringRef MissingRelocatableContent = R"(
+Sections:
+  - Name: .rela.text
+    Type: SHT_RELA
+    Flags: [ SHF_INFO_LINK ]
+    Info: 0xFF
+)";
+
+  DoCheckFails(MissingRelocatableContent, DefaultMatcher,
+               "SHT_RELA section with index 1: failed to get a "
+               "relocated section: invalid section index: 255");
+}
